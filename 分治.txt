实现归并算法的思路
背景：
逆向思维的产物。
对于两个相同长度（n/2）的顺序数列只需从头开始上下比较就可以（最多n-1）

问题是如何从非顺序的全列中获取顺序的子列
引入递归的方法
设数列为2^n 则不断二分下去得到底层的两组二元组，则可以通过一次比较得到两个二元顺序列
这两个二元组可以进行归并排序，并逐级向上传播得到最后的顺序列
方案一是不考虑形参实参共变的情况：
逐级递归至最后的二元形式，经一次比较得到最底层的顺序列，返回结果到上一层
方案二是考虑形参实参共变：
用索引的变化来实现结果的反馈
先对下一级进行处理
在处理本级

递归的关键是要找到停止条件
带返回的停条是找到极限条件比如数列长度，并返回极限值，且停止递归调用
不带返回的停条是找到停止递归的条件，转而执行特殊调用
注意到递归是天然阻塞的

快速排序的思路
背景：同样是只扫描一次就完成对其中一个元素的排序（特征是分割了大小的阈值）
然后由其拆分出两个子序列，运用分治的方法分别进行排序
最后减小了复杂度
第一步实现大小交换，（注意到对列表操作，一定要确保形参是列表而不是元素形式）
第二步实现首位元素的排序（注意在i，j交换的过程中，使用了循环操作来提高效率，精简代码）
第三步实现排序后的拆分和递归（注意带返回的方法一定要将返回的数据赋值会原数组）

输出前m大的数的思路
背景：不需要全排序而只在线性时间中，将最大的数移到最后，
确定分离的边界条件然后利用分治的思想，对其进行数移
满足m大后对其进行排序
第一步是分割成前a后n-a
第二步判断继续分割的条件使得序列不断向目标逼近
